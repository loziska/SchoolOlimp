def find_closest_weight(stones, W):
    N = len(stones)
    dp = [False] * (W + 1)
    dp[0] = True  # Можно набрать вес 0

    # Заполняем массив dp
    for p in stones:
        for w in range(W, p - 1, -1):
            if dp[w - p]:
                dp[w] = True

    # Находим максимальный w ≤ W, для которого dp[w] = True
    for w in range(W, -1, -1):
        if dp[w]:
            return w

    return 0  # Если нельзя набрать даже 0 (невозможный случай)

# Пример использования:
stones = [2, 4, 5, 7]
W = 10
result = find_closest_weight(stones, W)
print(f"Максимально близкий вес к {W}: {result}")

# Алгоритм:
# Инициализация массива dp:
# dp[w] будет хранить True, если можно набрать вес w из данных камней.
# Изначально dp[0] = True (можно набрать вес 0 без камней), остальные dp[w] = False.

# Заполнение массива dp:
# Для каждого камня весом p обновляем массив dp для всех весов от W вниз до p.
# Если dp[w - p] = True, то dp[w] тоже становится True (можно добавить текущий камень к комбинации веса w - p).

# Поиск ближайшего к W веса:
# После заполнения dp ищем максимальный w ≤ W, для которого dp[w] = True.
